# 📋 [Problem1 Solving]

## 📌 요구사항

1 ~ 400 페이지  
왼쪽은 홀수, 오른쪽은 짝수  
한 사람당 왼쪽, 오른쪽 페이지가 각각 주어짐.  
다음 규칙의 게임을 이긴 사람이 책을 갖는다.

1. 각 페이지 번호의 각 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구함.
2. 각 사람은 두 페이지의 점수 중, 가장 큰 점수를 자신의 점수라 하고 비교한다.
3. 첫번째, 마지막 페이지는 펼치지 않음. 즉, 1, 400 페이지는 입력 되지 않는다.
4. 포비가 이긴다면 1, 크롱이 이긴다면 2, 무승부는 0, 예외사항은 -1 로 return

## ❗예외사항

1. 왼쪽 오른쪽 페이지 번호가 같은 경우.
2. 왼쪽 페이지 번호가 오른쪽 페이지 번호보다 높은 경우.
3. 두 번호의 차이가 1을 넘어가는 경우.

=> 왼쪽페이지에서 오른쪽페이지를 뺏을 때 -1이 나오지 않는 경우들은 모두 에외상황이다.

## 📲 기능 목록

> 1. 페이지 번호의 각 숫자들을 더한 값을 구해준다. => _pageNumEachPlus 함수_
>
> - 숫자 리스트를 파라미터로 받는다. (parameter: numList)
> - 총합을 return 한다.
>
> 2. 페이지 번호의 각 숫자들을 곱한 값을 구해준다. => _pageNumEachMultiply 함수_
>
> - 숫자 리스트를 파라미터로 받는다. (parameter: numList)
> - 총곱을 return 한다.
>
> 3. 예외사항에 해당하는 것이 있는지 확인해준다. => _except 함수_

---

# 📋 [Problem2 Solving]

## 📌 요구사항

문자열이 주어진다. 문자열에서 2개 이상 중복되는 문자가 이어져있다면 삭제 시킨다.  
삭제된 빈자리를 다시 양쪽의 문자를 땡겨서 채운다.

위 과정을 반복해서 더 이상 중복되는 문자가 연이어 나오지 않는다면 그 문자를 return.

## 📝 해결전략

연속되는 문자가 짝수라면 기본 스택 넣는 방법을 쓰면 되지만, 이 방법을 쓰면 연속되는 문자 개수가 홀수일경우가 예외사항 발생한다.  
문자를 빈배열에 저장해가면서 이전에 담은 문자가 넣을 문자랑 같다면 배열에 저장하지 않는다.  
이때, 변수 하나를 boolean 값으로 설정하여 같은 단어가 연속으로 나오는 중인지를 체크하게 해준다.  
연속으로 삭제가 되다가 이제 값이 달라지면, boolean 값을 다시 바꿔주고 배열에 저장되어있는 연속되던 값을 pop 시키자.

최종적으로 남은 문자를 return

## 📲 기능 목록

1. 중복제거를 해주는 함수 deleteWords

---

# 📋 [Problem3 Solving]

## 📌 요구사항

1번 부터 주어진 숫자까지 369 게임을 실행.  
총 몇번의 박수를 쳤는지 구하여라.  
참고로, 각 숫자에서 3,6,9 숫자에 각각 한번씩 박수를 친다.

## 📝 해결전략

1번부터 숫자를 증가시키면서,  
각 문자의 369개수를 체크해주는 함수를 호출해 결과값을 더해나아가자.

## 📲 기능목록

1. 문자의 369 개수를 세어주는 함수. => cntNum function

---

# 📋 [Problem4 Solving]

## 📌 요구사항

입력되는 문자를 청개구리 사전을 참고하여 해당하는 문자로 바꾸어라.  
바꾼 결과값을 출력.

## 📝 해결전략

아스키코드를 이용해야겠다.  
A-Z 는 65번부터 90번, a-z 는 97번부터 122번  
우선, 대문자인지 소문자인지를 나눠주자.  
대문자일경우,  
주어지는 각 문자의 아스키코드값에서 65를 빼고 남은 숫자만큼을 90에서 빼어서  
그 결과값을 아스키코드로 변환하여 저장시켜주면 되겠다.  
소문자일 경우,
비슷하게 한다. 대신 65=>97, 90=>122으로 생각해서 풀면 되겠다.

## 📲 기능목록

1. 입력된 번호에 맞는 청개구리사전 문자를 return 시켜주는 함수. => frogDict function

---

# 📋 [Problem5 Solving]

## 📌 요구사항

돈의 액수를 줄 수 있는 화폐로 나눈다.  
이때, 화폐 개수의 총합이 최소가 되게 하여라.  
1<= money <=1000000

## 📝 해결전략

50000부터 1원까지 차례로 나눠가면서 몫을 더해주고 나머지만 게속 남아가게 하자.  
중간에 나머지가 0이 되면 종료.

## 📲 기능목록

1. 각 화페에 맞게 금액을 나눠서 나머지를 도출해나아가는 함수 => divideCurrency

---

# 📋 [Problem6 Solving]

## 📌 요구사항

닉네임 중 같은 글자가 연속적으로 포함 될 경우 두 계정 모두 사용 제한.  
사용제한이 걸린 계정의 이메일을 문자열 오름차순 정렬하여 return  
이때, 중복은 제거하라.

## 📝 해결전략

dict 를 사용하자.
닉네임의 연속된 조합 단어를 dict에 키값으로 저장하고 카운트 1씩해줌.  
이때, 같은 글자가 연속적으로 포함된다면 같은 키값을 가질 것이고, 카운트는 1이 넘어가게됨.  
이 값들을 찾아내어. 해당 키값을 가지고 있는 계정들의 이메일을 따로 저장.  
문자열 중복제거하고 정렬하여 출력.

## ⚠️ 주의!

refuseEmail 함수에서 map 을 사용하면 email 을 두번 이상 중복되게 추가할 수도 있으므로
for loop 사용했다.

## 📲 기능목록

1. 닉네임으로 만들어질 수 있는 연속된 문자열 생성시켜 return 해주는 함수 => makeKeys
2. 입력된 닉네임을 키값에 넣어주는 함수 => enterDict
3. 키값의 value 값이 2개 이상인 값들을 return 해주는 함수 => checkValue
4. 사용제한될 이메일을 return 해주는 함수 => refuseEmail

---

# 📋 [Problem7 Solving]

## 📌 요구사항

서로의 친구관계가 담긴 배열이 주어짐. 두명은 서로 친구라는 뜻.  
user 의 타임라인 방문자 리스트도 주어짐.

user 와 함께 아는 친구의 수 +=10  
user 타임라인 방문횟수 +=1

해서 0점과 현재이미 친구인 사람들을 제외한 사람들을 점수대로 내림차순 해서 출력하여라.  
점수가 같을 시 이름순 정렬. 출력값은 5명이 최대.

## 📝 해결전략

서로 친구에 대한 정보를 양방향으로 저장.  
dict에 각 아이디의 배열 index 번호 정보를 담아주자.  
해당 아이디의 index 번호에 해당 아이디의 친구 정보가 담겨있다.  
user 정보는 배열 0번째 인덱스에 저장.

## 📲 기능목록

1. friends 를 순회하면서 dict에 각 아이디 인덱스 정보와 배열을 생성해줄 함수  
   => createInfo , 파라미터 값: 친구 관계 friends, 인덱스 idx
2. 각 아이디의 점수를 카운트해줄 함수 => cntScore
3. 함께아는 친구의 수에 대한 정보를 점수화 시켜 카운트해줄 함수 => cntKnowScore
4. (1) 점수 내림차순  
   (2) 이름 내림차순  
   정렬 함수 => sortList
5. 결과값을 출력해주고 정렬하여 return 해줄 함수 => makeResult
